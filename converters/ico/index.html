<!-- PNG/JPG â†’ ICO ë³€í™˜ê¸° (íˆ¬ëª… ìœ ì§€, 16/32/48/64 ë™ì‹œ ë‚´ì¥) -->
<div style="background:#1e1e1e;padding:20px;border-radius:12px;color:#eee;font-family:'Noto Sans',system-ui,Segoe UI,Roboto,'Noto Sans KR',sans-serif;max-width:460px;margin:30px auto;text-align:center;box-shadow:0 0 10px rgba(0,0,0,.4);">
  <h3 style="margin-bottom:12px;font-weight:600;color:#fff;" data-ke-size="size23">PNG/JPG â†’ ICO ë³€í™˜</h3>
  <input id="imageInput" style="margin:12px 0;padding:8px;background:#2a2a2a;color:#ccc;border:1px solid #444;border-radius:6px;width:90%;" accept="image/png, image/jpeg" type="file" />
  <div style="margin:8px 0 4px;font-size:12px;color:#aaa;">PNG/JPG (ê¶Œì¥ 512Ã—512 ì´í•˜, 2MB ì´í•˜)</div>
  <button id="convertBtn" style="padding:10px 20px;margin-top:10px;border:none;border-radius:8px;background:#444;color:#fff;cursor:pointer;transition:.2s;">ë³€í™˜í•˜ê¸°</button>
  <p id="status" style="margin-top:15px;font-size:14px;color:#aaa;" data-ke-size="size16">&nbsp;</p>
  <a id="downloadLink" style="display:none;margin-top:15px;padding:10px 20px;background:#3b82f6;color:#fff;border-radius:6px;text-decoration:none;font-size:14px;">ğŸ“¥ favicon.ico ë‹¤ìš´ë¡œë“œ</a>
</div>

<script>
(async function () {
  const sizes = [16, 32, 48, 64];
  const inputEl = document.getElementById('imageInput');
  const btn = document.getElementById('convertBtn');
  const statusEl = document.getElementById('status');
  const linkEl = document.getElementById('downloadLink');
  let currentUrl = null;

  function setStatus(text, color) {
    statusEl.textContent = text || '';
    statusEl.style.color = color || '#aaa';
  }

  function drawToCanvas(img, size) {
    const c = document.createElement('canvas');
    c.width = c.height = size;
    const ctx = c.getContext('2d');
    ctx.clearRect(0, 0, size, size);

    const iw = img.width, ih = img.height;
    // contain: ì „ì²´ ì´ë¯¸ì§€ê°€ ë³´ì´ë„ë¡ ë¹„ìœ¨ ìœ ì§€(í¬ë¡­ ë°©ì§€). ë¹ˆ ê³µê°„ì€ íˆ¬ëª….
    const scale = Math.min(size / iw, size / ih);
    const nw = Math.round(iw * scale), nh = Math.round(ih * scale);
    const dx = Math.floor((size - nw) / 2), dy = Math.floor((size - nh) / 2);
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(img, dx, dy, nw, nh);
    return c;
  }

  function canvasToPNGAB(cnv) {
    return new Promise((resolve, reject) => {
      cnv.toBlob(b => {
        if (!b) return reject(new Error('PNG ë³€í™˜ ì‹¤íŒ¨'));
        const fr = new FileReader();
        fr.onload = () => resolve(fr.result);
        fr.onerror = reject;
        fr.readAsArrayBuffer(b);
      }, 'image/png');
    });
  }

  function buildICOFromPNGs(buffers) {
    const count = buffers.length;
    const headerSize = 6 + (16 * count);
    let offset = headerSize;
    let totalSize = headerSize;
    for (const buf of buffers) totalSize += buf.byteLength;

    const out = new Uint8Array(totalSize);
    const dv = new DataView(out.buffer);

    // ICONDIR
    dv.setUint16(0, 0, true); // reserved
    dv.setUint16(2, 1, true); // type: 1 = icon
    dv.setUint16(4, count, true); // count

    // ICONDIRENTRY + ì´ë¯¸ì§€ ë°ì´í„°
    let entryPos = 6;
    for (let i = 0; i < count; i++) {
      const ab = buffers[i];
      const view = new Uint8Array(ab);
      const imgSize = view.byteLength;
      const imgWidth = sizes[i];
      const imgHeight = sizes[i];

      out[entryPos + 0] = imgWidth === 256 ? 0 : imgWidth;  // width
      out[entryPos + 1] = imgHeight === 256 ? 0 : imgHeight; // height
      out[entryPos + 2] = 0; // colors in palette (PNGì´ë¯€ë¡œ 0)
      out[entryPos + 3] = 0; // reserved
      dv.setUint16(entryPos + 4, 1, true);  // color planes
      dv.setUint16(entryPos + 6, 32, true); // bits per pixel (PNG í—¤ë” ë¬´ì‹œë¨)
      dv.setUint32(entryPos + 8, imgSize, true); // size in bytes
      dv.setUint32(entryPos + 12, offset, true); // file offset
      entryPos += 16;

      out.set(view, offset);
      offset += imgSize;
    }

    return out.buffer;
  }

  btn.addEventListener('click', async () => {
    const file = inputEl.files && inputEl.files[0];
    if (!file) {
      alert('ì´ë¯¸ì§€ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš” (PNG ë˜ëŠ” JPG).');
      return;
    }

    if (!/^image\/(png|jpeg)$/i.test(file.type)) {
      alert('PNG ë˜ëŠ” JPG ì´ë¯¸ì§€ë§Œ ì§€ì›í•©ë‹ˆë‹¤.');
      return;
    }

    if (file.size > 2 * 1024 * 1024) {
      alert('íŒŒì¼ í¬ê¸°ëŠ” 2MB ì´í•˜ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤.');
      return;
    }

    setStatus('ì´ë¯¸ì§€ ë¡œë”© ì¤‘â€¦');
    btn.disabled = true;

    try {
      // ì´ë¯¸ì§€ ë¡œë“œ
      const dataUrl = await new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve(fr.result);
        fr.onerror = reject;
        fr.readAsDataURL(file);
      });

      const img = await new Promise((resolve, reject) => {
        const im = new Image();
        im.decoding = 'async';
        im.onload = () => resolve(im);
        im.onerror = () => reject(new Error('ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨'));
        im.src = dataUrl;
      });

      setStatus('PNG ì¤€ë¹„ ì¤‘â€¦');

      const pngABs = [];
      for (const s of sizes) {
        const cnv = drawToCanvas(img, s);
        const ab = await canvasToPNGAB(cnv);
        pngABs.push(ab);
      }

      setStatus('ICO íŒ¨í‚¤ì§• ì¤‘â€¦');

      const icoAB = buildICOFromPNGs(pngABs);
      const blob = new Blob([icoAB], { type: 'image/x-icon' });

      if (currentUrl) URL.revokeObjectURL(currentUrl);
      currentUrl = URL.createObjectURL(blob);

      linkEl.href = currentUrl;
      linkEl.download = 'favicon.ico';
      linkEl.style.display = 'inline-block';
      setStatus('âœ… ë³€í™˜ ì™„ë£Œ! ì•„ë˜ ë²„íŠ¼ìœ¼ë¡œ ì €ì¥í•˜ì„¸ìš”.', '#4ade80');
    } catch (e) {
      console.error(e);
      setStatus('ë³€í™˜ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì–´ìš”.', '#f87171');
      alert('ë³€í™˜ ì‹¤íŒ¨: ' + (e && e.message ? e.message : e));
    } finally {
      btn.disabled = false;
    }
  });
})();
</script>
